---
title: "Cell Hashing Example"
date: "`r Sys.Date()`"
output:
  rmdformats::html_clean:
    highlight: kate
    self_contained: yes
    thumbnails: yes
    fig_width: 12
    code_folding: hide
  html_document:
    df_print: paged
---

```{r setup}

library(cellhashR)
library(ggplot2)

knitr::opts_chunk$set(message=FALSE, warning=FALSE, echo=TRUE, error=TRUE)

knitr::opts_knit$set(root.dir = '/Projects/cellhashR')

```

# Library Saturation

```{r Saturation}

saturation <- cellhashR:::PlotLibrarySaturation('./tests/testdata/438-21-GEX')


```


# Data Loading / QC:

Load raw counts, perform basic filtering an QC. The input count matrix was generated to include all possible barcodes, even though this sample only contains 5. The figures demonstrate the other barcodes are absent, which is useful information to verify.

```{r QC1, fig.width=12}

barcodeDir <- './tests/testdata/cellHashing/247-1-hashTagCounts.txt'

barcodeData <- ProcessCountMatrix(rawCountData = barcodeDir, minCountPerCell = 5)
if (nrow(barcodeData) == 0) {
  print('No passing barcodes')
}

if (ncol(barcodeData) == 0) {
  print('No passing cells')
}

```

# Data Loading / QC Using Barcode Whitelist:

This is identical to above, except we provide a whitelist of the expected barcodes, which will be used to subset data. This is a more realistic usage example.


```{r QC2, fig.width=12}

barcodeDir <- './tests/testdata/cellHashing/247-1-hashTagCounts.txt'

barcodeData <- ProcessCountMatrix(rawCountData = barcodeDir, minCountPerCell = 5, barcodeWhitelist = c('HTO-1', 'HTO-2', 'HTO-3', 'HTO-4', 'HTO-6'))
if (nrow(barcodeData) == 0) {
  print('No passing barcodes')
}

if (ncol(barcodeData) == 0) {
  print('No passing cells')
}


```

# Normalization / QC

These plots are designed to provide visualization of potential normalizations.

```{r NormalizationQC, fig.width=12}

PlotNormalizationQC(barcodeData)


```

# Generate Hashing Calls

The actual hashing calls are generated below. One or more calling algorithms can be used. If multiple algorithms are selected, the consensus call is used, which is the union of all non-negative calls. Any discordant call is marked as such.

```{r GenerateCalls, fig.width=12}

if (nrow(barcodeData) > 0 && ncol(barcodeData) > 0){
	dt <- GenerateCellHashingCalls(barcodeMatrix = barcodeData, methods = c('multiseq', 'htodemux'))
} else {
	stop('No passing cels were found in the count matrix')
}

```

```{r fig.width=10}

barcodeData <- readRDS(file = 'barcodeData.rds')
cl <- readRDS(file = 'callList.rds')

df <- cellhashR:::ProcessEnsemblHtoCalls(cl, barcodeData)
	


  
```


```{r}



```


## Print Session Info

```{r SessionInfo}

sessionInfo()

```

