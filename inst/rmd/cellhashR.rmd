---
title: "cellhashR Example"
date: "`r Sys.Date()`"
output:
  rmdformats::html_clean:
    highlight: kate
    self_contained: yes
    thumbnails: yes
    fig_width: 12
    code_folding: hide

---

```{r setup}

library(cellhashR)

knitr::opts_chunk$set(message=FALSE, warning=FALSE, echo=TRUE, error=TRUE)

knitr::opts_knit$set(root.dir = '/Projects/cellhashR')

```

# Library Saturation

```{r Saturation}

saturation <- cellhashR:::PlotLibrarySaturation('./tests/testdata/438-21-GEX')


```


# Data Loading / QC:

Load raw counts, perform basic filtering an QC. The input count matrix was generated to include all possible barcodes, even though this sample only contains 5. The figures demonstrate the other barcodes are absent, which is useful information to verify.

```{r QC1, fig.width=12}

barcodeDir <- './tests/testdata/cellHashing/247-1-hashTagCounts.txt'

barcodeData <- ProcessCountMatrix(rawCountData = barcodeDir, minCountPerCell = 5, saveOriginalCellBarcodeFile = saveOriginalCellBarcodeFile)
if (nrow(barcodeData) == 0) {
  print('No passing barcodes')
}

if (ncol(barcodeData) == 0) {
  print('No passing cells')
}

```

# Data Loading / QC Using Barcode Whitelist:

This is identical to above, except we provide a whitelist of the expected barcodes, which will be used to subset data. This is a more realistic usage example.


```{r QC2, fig.width=12}

saveOriginalCellBarcodeFile <- 'originalBarcodes.txt'
barcodeData <- ProcessCountMatrix(rawCountData = barcodeDir, minCountPerCell = 5, barcodeWhitelist = c('HTO-1', 'HTO-2', 'HTO-3', 'HTO-4', 'HTO-6'), saveOriginalCellBarcodeFile = saveOriginalCellBarcodeFile)
if (nrow(barcodeData) == 0) {
  print('No passing barcodes')
}

if (ncol(barcodeData) == 0) {
  print('No passing cells')
}


```

# Normalization / QC

These plots are designed to provide visualization of potential normalizations.

```{r NormalizationQC, fig.width=12}

PlotNormalizationQC(barcodeData)


```

# Generate Hashing Calls

The actual hashing calls are generated below. One or more calling algorithms can be used. If multiple algorithms are selected, the consensus call is used, which is the union of all non-negative calls. Any discordant call is marked as such.

```{r GenerateCalls, fig.width=12}

if (nrow(barcodeData) > 0 && ncol(barcodeData) > 0){
	# Note: if you provide a vector of expected barcodes (such as all barcodes with passing gene expresison data), the plots will include these in the summary. This is useful to evaluate whether cells were dropped due to lack of cell hashing counts, as opposed to uncallable for other reasons.
	cellbarcodeWhitelist <- read.table(saveOriginalCellBarcodeFile, header = FALSE, col.names = c('cellbarcode'))
	df <- GenerateCellHashingCalls(barcodeMatrix = barcodeData, methods = c('multiseq', 'htodemux'), cellbarcodeWhitelist = saveOriginalCellBarcodeFile)
} else {
	stop('No passing cels were found in the count matrix')
}

```

# Final Calls

The output is a data frame, with the calls from each caller, and a consensus call.  See AppendCellHashing to append the results to a seurat object as metadata.

```{r}

knitr::kable(head(df, n = 10))

```

# Print Session Info

```{r SessionInfo}

sessionInfo()

```

