---
title: "`r params$doc_title`"
date: "`r Sys.Date()`"
params:
  doc_title: "Example cellhashR Report"
  skipNormalizationQc: false
output:
  rmdformats::html_clean:
    highlight: kate
    self_contained: yes
    keep_md: false
    thumbnails: yes
    fig_width: 12
    code_folding: hide
    gallery: true
    lightbox: true
    df_print: paged
---

```{r setup}

library(cellhashR)

knitr::opts_chunk$set(message=FALSE, warning=FALSE, echo=TRUE, error=FALSE)

```

```{r setupVariables, include=FALSE}

requiredVars <- c('rawCountData', 'callFile')
for (v in requiredVars) {
	if (!exists(v)) {
		stop(paste0('Need to define variable: ', v))
	}
}

if (!file.exists(rawCountData)) {
  stop(paste0('Could not find rawCountData: ', rawCountData))
}

optionalVars <- c('barcodeWhitelist', 'cellbarcodeWhitelist', 'citeSeqCountDir', 'minCountPerCell', 'metricsFile', 'rawCountsExport')
for (v in optionalVars) {
	if (!exists(v)) {
		if (v == 'minCountPerCell') {
			minCountPerCell <- 5
		} else {
			assign(v, NULL)
		}
	}
}

# If cellbarcodeWhitelist == inputMatrix, save/restore the set of cellbarcodes for reporting:
saveOriginalCellBarcodeFile <- NULL
if (!is.null(cellbarcodeWhitelist)) {
	if (cellbarcodeWhitelist == 'inputMatrix') {
		saveOriginalCellBarcodeFile <- 'originalBarcodes.txt'
		cellbarcodeWhitelist <- NULL
	}
}

# Truncate metricsFile if provided:
if (!is.null(metricsFile)) {
  file.create(metricsFile)
}

```

# Data Loading / QC

```{r QC}

if (!is.null(citeSeqCountDir)) {
  saturation <- PlotLibrarySaturation(citeSeqCountDir, metricsFile = metricsFile)
}

barcodeData <- ProcessCountMatrix(rawCountData = rawCountData, minCountPerCell = minCountPerCell, barcodeWhitelist = barcodeWhitelist, cellbarcodeWhitelist = cellbarcodeWhitelist, saveOriginalCellBarcodeFile = saveOriginalCellBarcodeFile, metricsFile = metricsFile)
if (nrow(barcodeData) == 0) {
  stop('No passing barcodes')
}

if (ncol(barcodeData) == 0) {
  stop('No passing cells')
}

if (!is.null(rawCountsExport)) {
  saveRDS(barcodeData, file = rawCountsExport)
}

if (!params$skipNormalizationQc) {
  PlotNormalizationQC(barcodeData)
}

```

# Generate Hashing Calls

```{r GenerateCalls}

df <- NULL
if (nrow(barcodeData) > 0 && ncol(barcodeData) > 0){

	if (!is.null(saveOriginalCellBarcodeFile)) {
	  cellbarcodeWhitelist <- read.table(saveOriginalCellBarcodeFile, header = FALSE, col.names = c('cellbarcode'))
	  cellbarcodeWhitelist <- cellbarcodeWhitelist$cellbarcode
  }

	df <- GenerateCellHashingCalls(barcodeMatrix = barcodeData, methods = methods, cellbarcodeWhitelist = cellbarcodeWhitelist, metricsFile = metricsFile)
	write.table(df, file = callFile, sep = '\t', row.names = FALSE, quote = FALSE)

	if (!is.null(saveOriginalCellBarcodeFile)) {
	  unlink(saveOriginalCellBarcodeFile)
  }
} else {
	stop('No passing cels were found in the count matrix')
}

```

# Final Calls

```{r FinalCalls}

if (!is.null(df)) {
  knitr::kable(head(df, n = 10))
}

```

# Summary of Negative Cells

```{r SummarizeNegatives}

if (!is.null(df)) {
  SummarizeCellsByClassification(calls = df, barcodeMatrix = barcodeData)
} else {
  print('Something went wrong scoring cells')
}

```

# Metrics

```{r Metrics}

if (!is.null(metricsFile)) {
  metrics <- read.table(metricsFile, sep = '\t')
  names(metrics) <- c('Category', 'Metric', 'Value')
  knitr::kable(metrics[c('Metric', 'Value')])
}

```

# Print Session Info

```{r SessionInfo}

sessionInfo()

```

